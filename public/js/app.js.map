{"version":3,"sources":["app/BattleWave.coffee","app/src/Clock.coffee","app/src/Surface.coffee","app/src/WarpGrid.coffee","node_modules/auto-reload-brunch/vendor/auto-reload.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhDA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzBA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApFA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjIA;AAAA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"public/js/app.js","sourcesContent":["\"use strict\";\nvar BattleWave, Clock, Surface, WarpGrid;\n\nClock = require('src/Clock');\n\nSurface = require('src/Surface');\n\nWarpGrid = require('src/WarpGrid');\n\nmodule.exports = BattleWave = (function() {\n  function BattleWave(target1) {\n    this.target = target1;\n    this.clock = new Clock();\n    this.surface = new Surface(this.target);\n    this.loopId = null;\n  }\n\n  BattleWave.prototype.deltaTime = function() {\n    return this.clock.deltaTime();\n  };\n\n  BattleWave.prototype.start = function() {\n    console.log('[BattleWave] Starting');\n    return this.loopId = requestAnimationFrame(this.gameLoop.bind(this));\n  };\n\n  BattleWave.prototype.stop = function() {\n    console.log('[BattleWave] Stopping');\n    return cancelAnimationFrame(this.loopId);\n  };\n\n  BattleWave.prototype.gameLoop = function() {\n    this.surface.clear();\n    this.surface.render();\n    return this.loopId = requestAnimationFrame(this.gameLoop.bind(this));\n  };\n\n  return BattleWave;\n\n})();\n\ndocument.addEventListener('DOMContentLoaded', function() {\n  var bw, target;\n  console.log('[BattleWave] Initializing');\n  target = document.getElementById('target');\n  bw = new BattleWave(target);\n  return bw.start();\n});\n","\"use strict\";\nvar Clock;\n\nmodule.exports = Clock = (function() {\n  var getCurrentTime;\n\n  function Clock() {\n    this.time = getCurrentTime();\n  }\n\n  Clock.prototype.deltaTime = function() {\n    var delta, now;\n    now = getCurrentTime();\n    delta = now - this.time;\n    this.time = now;\n    return delta / 1000;\n  };\n\n  getCurrentTime = function() {\n    return (new Date()).getTime();\n  };\n\n  return Clock;\n\n})();\n","\"use strict\";\nvar Surface, WarpGrid;\n\nWarpGrid = require('src/WarpGrid');\n\nmodule.exports = Surface = (function() {\n  var registerResize, resizeScene;\n\n  function Surface(target) {\n    var _this;\n    this.canvas = document.createElement('CANVAS');\n    target.appendChild(this.canvas);\n    this.context = this.canvas.getContext('2d');\n    this.objects = [];\n    this.setupComposer();\n    (registerResize.bind(this))();\n    (resizeScene.bind(this))(window);\n    this.grid = new WarpGrid(this.width(), this.height());\n    this.add(this.grid);\n    _this = this;\n    this.canvas.onmousemove = function(e) {\n      var posx, posy;\n      posx = e.clientX;\n      posy = e.clientY;\n      return _this.grid.setWavePoint({\n        originX: posx,\n        originY: posy\n      });\n    };\n  }\n\n  Surface.prototype.setupComposer = function() {\n    return console.log('[Surface] Setting up composer');\n  };\n\n  Surface.prototype.width = function() {\n    return this.canvas.width;\n  };\n\n  Surface.prototype.height = function() {\n    return this.canvas.height;\n  };\n\n  Surface.prototype.clear = function() {\n    return this.context.clearRect(0, 0, this.width(), this.height());\n  };\n\n  Surface.prototype.add = function(obj) {\n    return this.objects.push(obj);\n  };\n\n  Surface.prototype.render = function() {\n    var i, len, obj, ref, results;\n    this.context.fillStyle = '#212121';\n    this.context.fillRect(0, 0, this.width(), this.height());\n    ref = this.objects;\n    results = [];\n    for (i = 0, len = ref.length; i < len; i++) {\n      obj = ref[i];\n      results.push(obj.draw(this.context));\n    }\n    return results;\n  };\n\n  resizeScene = function(win) {\n    var height, width;\n    console.log('[Surface] Resizing');\n    height = win.innerHeight;\n    width = win.innerWidth;\n    this.canvas.width = width;\n    return this.canvas.height = height;\n  };\n\n  registerResize = function() {\n    var _this;\n    _this = this;\n    return window.addEventListener('resize', function(e) {\n      return (resizeScene.bind(_this))(e.target);\n    });\n  };\n\n  return Surface;\n\n})();\n","\"use strict\";\nvar WarpGrid;\n\nmodule.exports = WarpGrid = (function() {\n  var dist;\n\n  WarpGrid.GRID_COUNT = 50;\n\n  WarpGrid.prototype.type = \"WarpGrid\";\n\n  function WarpGrid(size) {\n    var i, j, ref, ref1, row, x, xcoord, y, ycoord;\n    this.points = [];\n    for (y = i = 0, ref = WarpGrid.GRID_COUNT; 0 <= ref ? i <= ref : i >= ref; y = 0 <= ref ? ++i : --i) {\n      row = [];\n      for (x = j = 0, ref1 = WarpGrid.GRID_COUNT; 0 <= ref1 ? j <= ref1 : j >= ref1; x = 0 <= ref1 ? ++j : --j) {\n        xcoord = x * (size / WarpGrid.GRID_COUNT);\n        ycoord = y * (size / WarpGrid.GRID_COUNT);\n        row.push({\n          x: x,\n          y: y,\n          originX: xcoord,\n          originY: ycoord,\n          currentX: xcoord,\n          currentY: ycoord,\n          weight: 0\n        });\n      }\n      this.points.push(row);\n    }\n  }\n\n  dist = function(left, right) {\n    var dx, dy;\n    dx = (right.originX - left.originX) / WarpGrid.GRID_COUNT;\n    dy = (right.originY - left.originY) / WarpGrid.GRID_COUNT;\n    return {\n      dx: dx,\n      dy: dy,\n      dist: Math.sqrt(dx * dx + dy * dy)\n    };\n  };\n\n  WarpGrid.prototype.setWavePoint = function(origin) {\n    var distance, i, len, pt, ref, results, row;\n    ref = this.points;\n    results = [];\n    for (i = 0, len = ref.length; i < len; i++) {\n      row = ref[i];\n      results.push((function() {\n        var j, len1, results1;\n        results1 = [];\n        for (j = 0, len1 = row.length; j < len1; j++) {\n          pt = row[j];\n          distance = dist(origin, pt);\n          pt.weight = 100 - (Math.abs(distance.dist) * 30);\n          if (pt.weight < 0) {\n            results1.push(pt.weight = 0);\n          } else {\n            results1.push(void 0);\n          }\n        }\n        return results1;\n      })());\n    }\n    return results;\n  };\n\n  WarpGrid.computeColor = function(ctx, left, right) {\n    var colLeft, colRight, grad, hue, light;\n    grad = ctx.createLinearGradient(0, 0, right.currentX - left.currentX, right.currentY - left.currentY);\n    hue = Math.round(280 - left.weight);\n    light = 40 + Math.round(left.weight * 0.6);\n    colLeft = tinycolor(\"hsl(\" + hue + \", \" + light + \"%, \" + light + \"%)\").toHexString();\n    hue = Math.round(280 - right.weight);\n    light = 40 + Math.round(right.weight * 0.6);\n    colRight = tinycolor(\"hsl(\" + hue + \", \" + light + \"%, \" + light + \"%)\").toHexString();\n    grad.addColorStop(0, colLeft);\n    grad.addColorStop(1, colRight);\n    return grad;\n  };\n\n  WarpGrid.prototype.draw = function(ctx) {\n    var i, j, k, len, len1, previous, pt, ref, ref1, results, row, x, y;\n    ctx.lineWidth = 1;\n    ref = this.points;\n    for (i = 0, len = ref.length; i < len; i++) {\n      row = ref[i];\n      previous = row[0];\n      for (j = 0, len1 = row.length; j < len1; j++) {\n        pt = row[j];\n        ctx.strokeStyle = WarpGrid.computeColor(ctx, previous, pt);\n        ctx.beginPath();\n        ctx.moveTo(previous.currentX, previous.currentY);\n        if (pt === previous) {\n          continue;\n        }\n        ctx.lineTo(pt.currentX, pt.currentY);\n        ctx.stroke();\n        previous = pt;\n      }\n    }\n    results = [];\n    for (x = k = 0, ref1 = WarpGrid.GRID_COUNT; 0 <= ref1 ? k <= ref1 : k >= ref1; x = 0 <= ref1 ? ++k : --k) {\n      previous = this.points[0][x];\n      results.push((function() {\n        var l, ref2, results1;\n        results1 = [];\n        for (y = l = 0, ref2 = WarpGrid.GRID_COUNT; 0 <= ref2 ? l <= ref2 : l >= ref2; y = 0 <= ref2 ? ++l : --l) {\n          pt = this.points[y][x];\n          if (pt === previous) {\n            continue;\n          }\n          ctx.strokeStyle = WarpGrid.computeColor(ctx, previous, pt);\n          ctx.beginPath();\n          ctx.moveTo(previous.currentX, previous.currentY);\n          ctx.lineTo(pt.currentX, pt.currentY);\n          ctx.stroke();\n          results1.push(previous = pt);\n        }\n        return results1;\n      }).call(this));\n    }\n    return results;\n  };\n\n  return WarpGrid;\n\n})();\n","/* jshint ignore:start */\n(function() {\n  var WebSocket = window.WebSocket || window.MozWebSocket;\n  var br = window.brunch = (window.brunch || {});\n  var ar = br['auto-reload'] = (br['auto-reload'] || {});\n  if (!WebSocket || ar.disabled) return;\n  if (window._ar) return;\n  window._ar = true;\n\n  var cacheBuster = function(url){\n    var date = Math.round(Date.now() / 1000).toString();\n    url = url.replace(/(\\&|\\\\?)cacheBuster=\\d*/, '');\n    return url + (url.indexOf('?') >= 0 ? '&' : '?') +'cacheBuster=' + date;\n  };\n\n  var browser = navigator.userAgent.toLowerCase();\n  var forceRepaint = ar.forceRepaint || browser.indexOf('chrome') > -1;\n\n  var reloaders = {\n    page: function(){\n      window.location.reload(true);\n    },\n\n    stylesheet: function(){\n      [].slice\n        .call(document.querySelectorAll('link[rel=stylesheet]'))\n        .filter(function(link) {\n          var val = link.getAttribute('data-autoreload');\n          return link.href && val != 'false';\n        })\n        .forEach(function(link) {\n          link.href = cacheBuster(link.href);\n        });\n\n      // Hack to force page repaint after 25ms.\n      if (forceRepaint) setTimeout(function() { document.body.offsetHeight; }, 25);\n    },\n\n    javascript: function(){\n      var scripts = [].slice.call(document.querySelectorAll('script'));\n      var textScripts = scripts.map(function(script) { return script.text }).filter(function(text) { return text.length > 0 });\n      var srcScripts = scripts.filter(function(script) { return script.src });\n\n      var loaded = 0;\n      var all = srcScripts.length;\n      var onLoad = function() {\n        loaded = loaded + 1;\n        if (loaded === all) {\n          textScripts.forEach(function(script) { eval(script); });\n        }\n      }\n\n      srcScripts\n        .forEach(function(script) {\n          var src = script.src;\n          script.remove();\n          var newScript = document.createElement('script');\n          newScript.src = cacheBuster(src);\n          newScript.async = true;\n          newScript.onload = onLoad;\n          document.head.appendChild(newScript);\n        });\n    }\n  };\n  var port = ar.port || 9485;\n  var host = br.server || window.location.hostname || 'localhost';\n\n  var connect = function(){\n    var connection = new WebSocket('ws://' + host + ':' + port);\n    connection.onmessage = function(event){\n      if (ar.disabled) return;\n      var message = event.data;\n      var reloader = reloaders[message] || reloaders.page;\n      reloader();\n    };\n    connection.onerror = function(){\n      if (connection.readyState) connection.close();\n    };\n    connection.onclose = function(){\n      window.setTimeout(connect, 1000);\n    };\n  };\n  connect();\n})();\n/* jshint ignore:end */\n"]}